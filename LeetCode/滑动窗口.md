## 滑动窗口

- 使用场景：某些连续子区间类问题，可将复杂度从 $O(n^2)$ 降至 $O(n)$ 

  Q: 什么时候可以用滑动窗口降低复杂度？

  A: **如果能够保证l和r中某一个增加的时候另一个确定不需要回溯**（也只需要增加）就可以使用滑动窗口

比如LeetCode209. 长度最小的子数组。如果r增加，那么任何l回溯的方案都不可能比之前的最优方案更小——因为[l-1, r) 已经被记录了。因此可以滑动窗口。但如果本题取消正数的条件，那这个性质就没有了。比如反例[2, -3, 4, 2], target = 4. 究其原因是因为取消正数条件之后失去了增加长度等价于增大和的单调性，因此为了确定最优情况必须在改变l或r之后遍历另一个才行。

```c++
//在[0, n)上滑动窗口
int l = 0;
int r = 0;
while(true){
	if (窗口扩张条件){
		if (r >= n) break;//左闭右开区间[left, right）比较方便
		操作
        ++r;//窗口扩张
    }
    else{
        if (l >= n) break;//左闭右开区间[left, right）比较方便
        操作
        ++l;//窗口收缩
    }
}
```

**某LeetCode答主的解题思路：**
连着做了好几道滑动窗口的题目，实现滑动窗口的框架是定死的，用left，right来刻画窗口，窗口区间为[left, right)，注意为半开半闭。框架如下：

```c++
void slidwindow(vector<int> nums)
{
    int left = 0, right = 0;
    while(right < nums.size())
    {
        ...//扩大右边界并更新窗口状态
        right++;
        while(需要收缩)//窗口到达什么状态需要收缩
        {
            ...//缩小左边界并更新窗口状态
            left++;
        }
    }
}
```

滑动窗口重点在于：
需要关注窗口的状态是什么？
需要如何刻画当前窗口的状态？
窗口到达什么状态时需要收缩？



e.g. LeetCode713乘积小于K的子数组