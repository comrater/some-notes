## 动态规划

- 动态规划方法的使用前提：
  - **最优子结构性质**：问题的最优解由子问题的最优解得到，且子问题可以独立求解。
  - **重叠子问题**：子问题是重叠可复用的（与分治法的区别所在，分治法的子问题是相互独立的）

**从数学视角看实际上就是把问题建模成 $f_n$ 并找到递推公式。**

- 动态规划问题的分析方法：
  1. **分析问题结构**：把问题建模成计算 $f_n$ 
  2. **建立递推关系**：找到递推公式，关键是**寻找最优子结构性质**，即子问题的解如何推出父问题的解
  3. 递推计算最优值：先确定**初值**和**计算次序**，再利用初值和状态转移方程递推计算
  4. 追踪最优方案：如果不仅要求解，还需要知道解是如何得到时才需要这一步

- 注意事项：

  - 动态规划有实现两种方式：自顶向下（带备忘录的递归）和自底向上。一般为了减少递归调用的额外开销，多使用自底向上的实现方式。

  - 根据状态转移方程的形式，动态规划有时可以进行**状态压缩**以减小空间复杂度

### 例题详解：

- LeetCode 53. 最大子数组和（经典例题：简单难度）

  > 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
  >
  > **子数组** 是数组中的一个连续部分。

  问题分析：

  > 全体连续子数组 $[l, r]$ 一共有 $O(n^2)$ 个，故暴力计算的时间复杂度不会低于 $O(n^2)$。但这个问题满足动态规划的条件。设 `nums` 中以 $i$ 结尾的最大子数组和为 $\text{dp}[i]$，那么**以 $i$ 结尾的最大子数组和要么在以 $i$ 结尾的最大子数组和的基础上加上 `nums[i + 1]` ，要么就从 `nums[i + 1]` 重新开始。**
  >
  > 所以有状态转移方程：
  > $$
  > \text{dp}[i] = \max \{ \text{dp}[i - 1] + \text{nums}[i],\ \text{nums}[i] \}
  > $$
  > 最终 $\max_{i = 1}^n {\text{dp}[i]}$ 即为所求。
  >
  > 注意：本题由于状态转移方程只和前一状态有关，故可状态压缩空间复杂度为$O(1)$.

- LeetCode 1143. 最长公共子序列（经典例题：中等难度）

  > 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
  >
  > 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
  >
  > 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
  > 两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

  问题分析：

  > **求最长公共子序列可以从末尾开始比较：**
  >
  > Case1. 如果两个字符串的末尾相同，那么选中它们的末尾加入最长公共子序列必定是一个最优的方案，因此此时可以同时去掉这两个字符串的结尾。（即方程第一行）
  >
  > Case2. **如果两个字符串的末尾不同，那么这两个末尾必然不可能同时被选入最长公共子序列，这时候分别考虑去掉这两个字符的两种情况，选择公共子序列更长的方案**。（即方程第二行）
  >
  > 令 $\text{dp}[i][j]$ 表示 `text1[0, i)` 和 `text2[0, j)` 的最长公共子序列，则有状态转移方程
  > $$
  > \text{dp}[i][j]= 
  > \begin{cases}
  > \text{dp}[i-1][j-1]+1, & \operatorname{text}_{1}[i-1]=\operatorname{text}_{2}[j-1] 
  > \\ \max \{ \text{dp}[i-1][j],\ \text{dp}[i][j-1] \}, & \operatorname{text}_{1}[i-1] \neq \operatorname{text}_{2}[j-1]
  > \end{cases}
  > $$
  > 最终 $\text{dp}[m][n]$ 即为所求。
  >
  > 注意：本题由于状态转移方程只和前一状态有关，故可状态压缩空间复杂度为$O(\min\{ m, n\})$.

- LeetCode 72. 编辑距离（经典例题：进阶难度）

  > 给你两个单词 `word1` 和 `word2`， 请返回将 `word1` 转换成 `word2` 所使用的最少操作数  。
  >
  > 你可以对一个单词进行如下三种操作：
  >
  > - 插入一个字符
  > - 删除一个字符
  > - 替换一个字符
  >
  > 示例：
  >
  > ​	输入：word1 = "horse", word2 = "ros"
  > ​	输出：3
  > ​	解释：
  > ​		horse -> rorse (将 'h' 替换为 'r')
  > ​		rorse -> rose (删除 'r')
  > ​		rose -> ros (删除 'e')

  问题分析：

  > 首先分析编辑距离的三种操作，不难得到以下三种情况是等效的：
  >
  > - 在两个单词上 插入/删除/替换
  > - 在一个单词上 插入/删除/替换
  > - 在两个单词上 删除/替换
  >
  > 而两个单词在同一个位置上的字母如果相同，那么就可以直接删掉。替换操作必然也会替换为相同字母。因此用第三种情况理解，就可以逐渐缩短编辑距离，直到某一个单词为空。
  >
  > 编辑距离问题看似复杂，但类似最长公共子序列问题，**也可以从末尾开始比较：**
  >
  > Case1. 如果两个字符串的末尾相同，那么同时去掉这两个字符串的结尾，并不会改变编辑距离。（即方程第一行）
  >
  > Case2. **如果两个字符串的末尾不同，那么为了让两个单词相同，必须对末尾进行某种操作，其中替换相当于同时删除两个的末尾**。（即方程第二行）
  >
  > 令 $\text{dp}[i][j]$ 表示 `word1[0, i)` 和 `word2[0, j)` 的编辑距离，则有状态转移方程
  > $$
  > \text{dp}[i][j]= 
  > \begin{cases}
  > \text{dp}[i-1][j-1], & \operatorname{word}_{1}[i-1]=\operatorname{word}_{2}[j-1] 
  > \\ \max \{ \text{dp}[i-1][j],\ \text{dp}[i][j-1],\ \text{dp}[i-1][j-1] \} + 1, & \operatorname{word}_{1}[i-1] \neq \operatorname{word}_{2}[j-1]
  > \end{cases}
  > $$
  > 最终 $\text{dp}[m][n]$ 即为所求。
  >
  > 注意：本题由于状态转移方程只和前一状态有关，故可状态压缩空间复杂度为$O(\min\{ m, n\})$.