# 堆/优先队列

**(二叉)堆**可以被看作一个完全二叉树。用数组实现。

**计算父与子**：如果 `A[0]` 位不用，用 `A[1]` 位作为根节点，那么 `A[i]` 的两个孩子（如果有）就是 `A[2i]` 和 `A[2i+1]` ；`A[i]` 的父亲（如果`A[i]`不是根）就是 `A[i/2]` 。

**堆的性质**：对于任何子树，根节点永远是最大(或最小)的。

**堆允许的操作**有：

- 将一个数组构建为堆
- 返回/删除堆顶元素——需要 `heapify_downwards`
- 在堆中加入元素——需要 `heapify_upwards`

注意到堆有两个原子的调整操作：上浮（在末尾插入新元素时使用）、下沉（弹出堆顶元素并和末尾交换时使用），二者均可迭代或**尾递归**实现，时间复杂度与堆的高度成正比，即对数级；空间复杂度为常数。

**建堆**有两种方法：

- 借助上浮操作，可以按照从小到大的顺序依次让元素上浮，相当于在空堆里不断插入新元素。这种方式的时间复杂度是 $O(n *\log n)$。
- 借助下沉操作，可以**按照从大到小的顺序依次让元素下沉**，（编号后一半的是叶子节点可以直接跳过）其正确性可以理解为：每次下沉操作后的子树（以及根的编号更大的子树）都已经成为了堆。可以证明**这种方式建堆的时间复杂度是 $O(n)$ 的**。**比前一个方式好的原因是这一方式让更多的节点走了更少的路——二叉树在底层的节点多，所以向下调整对多数节点更近。**

```c++
//(二叉)堆:(heap, heapify_upwards, heapify_downwards, build_heap, top, pop, push)
vector<ElemType> heap(n + 1);//[1, ..., n]为堆, 以最大堆为例

//向上调整(尾递归实现)
void heapify_upwards(int i, vector<ElemType>& heap){
    if (i == 1)	return;//到根节点为止
    if (heap[i / 2] >= heap[i])	return;//如果父节点更大, 调整结束
    swap(heap[i], heap[i / 2]);//否则和父节点交换
    heapify_upwards(i / 2, heap);//继续调整父节点
}

//向上调整(迭代实现)
void heapify_upwards(int i, vector<ElemType>& heap){
    while(i > 1){//如果还没到根节点
        if (heap[i / 2] >= heap[i])	return;//如果父节点更大, 调整结束
        swap(heap[i], heap[i / 2]);//否则和父节点交换
        i = i / 2;//继续调整父节点
    }
    return;
}

//向下调整(尾递归实现)
void heapify_downwards(int i, vector<ElemType>& heap){
    if (2 * i > n)	return;//到叶节点为止
    if (heap[i] >= heap[2 * i] && heap[i] >= heap[2 * i + 1]){
        return;////如果父节点更大, 调整结束
    }
    int large = (heap[2 * i] >= heap[2 * i + 1])? (2 * i) : (2 * i + 1);
    swap(heap[i], heap[large]);//否则将最大的换到父节点
    heapify_downwards(large, heap);//继续调整换过的子节点
}

//向下调整(迭代实现)
void heapify_downwards(int i, vector<ElemType>& heap){
    while(2 * i <= n){//如果还没到叶节点
        if (heap[i] >= heap[2 * i] && heap[i] >= heap[2 * i + 1]){
        	return;////如果父节点更大, 调整结束
    	}
        int large = (heap[2 * i] >= heap[2 * i + 1])? (2 * i) : (2 * i + 1);
    	swap(heap[i], heap[large]);//否则将最大的换到父节点
        i = large;//继续调整换过的子节点
    }
	return;
}
    
    
//复杂度为O(n logn)的建堆方法:
void build_heap_slower(vector<ElemType>& heap){
    for(int i = 1; i <= n; ++i){//正序遍历所有节点(相当于一个个加入堆的过程)
        heapify_upwards(i, heap);//让子数组heap[1,...,i]满足堆的性质
    }
    return;
}

//复杂度为O(n)的建堆方法:
void build_heap(vector<ElemType>& heap){
    for(int i = n/2; i >= 1; --i){//倒序遍历所有有孩子的节点
        heapify_downwards(i, heap);//让[i,...n]为根的这些子树都满足堆的性质
    }
    return;
}

//返回堆顶元素:
ElemType top(vector<ElemType>& heap){
    return heap[1];
}

//删除堆顶元素: 把最后一个元素和堆顶元素交换位置 -> 删除最后一个元素 -> 新堆顶向下调整 
void pop(vector<ElemType>& heap){
    swap(heap[1], heap.back());//把最后一个元素和堆顶元素交换位置
    heap.pop_back();//删除最后一个元素
    heapify_downwards(1, heap);//新堆顶向下调整
    return;
}

//插入元素: 把元素插入末尾 -> 末尾元素向上调整 
void push(ElemType elem, vector<ElemType>& heap){
    heap.push_back(elem)//把elem插入末尾
    heapify_upwards(heap.size() - 1, heap);//末尾元素向上调整
    return;
}


//堆排序: 建堆 -> 不断删除堆顶元素直到堆空
void heap_sort(vector<ElemType>& nums){//给nums[1,...,n]排序
    build_heap(nums);//建堆
    for(int i = nums.size() - 1; i >= 1; --i){
        swap(nums[1], nums[i]);//把最后一个元素和堆顶元素交换位置
    }
    //减少heapsize, 调整的时候不改变已经排好序的元素
    heapify_downwards(1, nums);//新堆顶向下调整
    return;
}
```

堆的基本用法包括：

- 堆排序：不断返回/删除堆顶元素即可
- 优先队列：如第K大的数类问题
- 